using Editor;
using Shared;
using System.Drawing;

namespace MapEditor;

public class Zone : StateComponentWithModel<ZoneModel>
{
    #region model section
    public string name { get => TrGetD(model.name); set => TrSetV(value, ValidateStringIsSet()); }
    public string zoneType { get => TrGetD(model.zoneType); set => TrSet(value); }
    public GridRectSC? gridRect { get => TrGetD(GridRectSC.TryNew(context, model.gridRect)); set => TrSet(value); }
    public RectSC? rect { get => TrGetD(RectSC.TryNew(context, model.rect)); set => TrSet(value); }
    public string properties { get => TrGetD(model.properties); set => TrSet(value); }
    public bool autoGenerated { get => TrGetD(model.autoGenerated); set => TrSet(value); }

    public ZoneModel ToModel()
    {
        return new ZoneModel(name, zoneType, gridRect, rect, properties, autoGenerated);
    }

    #endregion

    public ZoneType zoneTypeObj => ZoneTypes.GetZoneTypeObj(zoneType);
    public string propertyHelpText => zoneTypeObj.propertyHelpText.IsSet() ? $"Properties format: {zoneTypeObj.propertyHelpText}" : "";

    public Zone(EditorContext context, ZoneModel model) : base(context, model)
    {
    }

    public static Zone New(EditorContext context, string name, string zoneType, GridRect gridRect, int tileSize)
    {
        GridRect? gridRectToUse = null;
        MyRect? rectToUse = null;

        ZoneType zoneTypeObj = ZoneTypes.GetZoneTypeObj(zoneType);
        if (zoneTypeObj.isGridBased)
        {
            gridRectToUse = new GridRectSC(context, gridRect);
        }
        else
        {
            rectToUse = new RectSC(context, gridRect.GetRect(tileSize));
        }

        return new Zone(context, new(name, zoneType, gridRectToUse, rectToUse, "", false));
    }

    public void Draw(Drawer drawer, int tileSize)
    {
        MyRect rect = GetRect(tileSize);

        drawer.DrawRect(rect, null, zoneTypeObj.displayColor, 2, offX: -0.5f, offY: -0.5f);

        float fontSize = 12;
        drawer.DrawText(name, rect.x1 + 2, rect.y1 + 12, zoneTypeObj.displayColor, Color.Black, fontSize);
    }

    public void Inc(int x1, int y1, int x2, int y2)
    {
        if (gridRect != null)
        {
            gridRect.i1 += y1;
            gridRect.j1 += x1;
            gridRect.i2 += y2;
            gridRect.j2 += x2;
        }
        else if (rect != null)
        {
            rect.x1 += x1;
            rect.y1 += y1;
            rect.x2 += x2;
            rect.y2 += y2;
        }
    }

    public MyRect GetRect(int tileSize)
    {
        MyRect rect;
        if (this.rect != null)
        {
            rect = this.rect;
        }
        else
        {
            rect = gridRect!.ToModel().GetRect(tileSize);
        }
        return rect;
    }

    public int x1
    {
        get
        {
            return gridRect?.j1 ?? rect!.x1;
        }
        set
        {
            context.ApplyUICommitContextIfExists(() =>
            {
                if (gridRect != null) gridRect.j1 = value;
                else rect!.x1 = value;
                QueueOnPropertyChanged(nameof(x1));
            });
        }
    }

    public int y1
    {
        get
        {
            return gridRect?.i1 ?? rect!.y1;
        }
        set
        {
            context.ApplyUICommitContextIfExists(() =>
            {
                if (gridRect != null) gridRect.i1 = value;
                else rect!.y1 = value;
                QueueOnPropertyChanged(nameof(y1));
            });
        }
    }

    public int x2
    {
        get
        {
            return gridRect?.j2 ?? rect!.x2;
        }
        set
        {
            context.ApplyUICommitContextIfExists(() =>
            {
                if (gridRect != null) gridRect.j2 = value;
                else rect!.x2 = value;
                QueueOnPropertyChanged(nameof(x2));
            });
        }
    }

    public int y2
    {
        get
        {
            return gridRect?.i2 ?? rect!.y2;
        }
        set
        {
            context.ApplyUICommitContextIfExists(() =>
            {
                if (gridRect != null) gridRect.i2 = value;
                else rect!.y2 = value;
                QueueOnPropertyChanged(nameof(y2));
            });
        }
    }
}
